<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SysEx Controller</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    h1 {
      color: #444;
    }

    .control-group {
      margin-bottom: 20px;
      border: 1px solid #ddd;
      padding: 15px;
      border-radius: 8px;
    }

    label {
      display: block;
      margin-top: 10px;
    }

    input,
    select,
    button {
      margin-top: 5px;
    }

    button {
      padding: 10px;
      background-color: #0078D7;
      color: white;
      border: none;
      cursor: pointer;
    }

    button:hover {
      background-color: #005EA2;
    }
  </style>
</head>

<body>
  <h1>SysEx MIDI Controller</h1>
  <button onclick="menos()">menos</button>
  <button onclick="mas()">mas</button>

  <script>
    var valorActual = 29 ;
    var testHexValue = "00";
    var mas = function () {
      valorActual++;
      testHexValue = valorActual.toString(16).padStart(2, '0').toUpperCase();
      console.log(valorActual + " " + testHexValue);
      sendSysEx(getSysex());

    }

    var menos = function () {
      valorActual--;
      testHexValue = valorActual.toString(16).padStart(2, '0').toUpperCase();
      console.log(valorActual + " " + testHexValue);
      sendSysEx(getSysex());

    }
    var hexCompleto = "F0 44 00 00 70 20 60 06 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 02 00 00 00 00 01 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 07 00 07 07 0F 0F 0C 0B 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 0B 00 00 07 00 0F 07 0F 0F 04 0C 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 0C 00 00 07 00 00 04 00 08 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 0C 00 00 00 0A 00 00 02 00 01 01 00 00 00 00 01 00 07 07 0F 07 0E 0B 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 01 00 0F 07 0A 06 05 0C 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 01 00 0F 07 0E 03 01 0E 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 F7";
    var hexTest = "00 00 00 00 07 00 07 07 0F 0F 0C 0B 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 0B 00 00 07 00 0F 07 0F 0F 04 0C 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 0C 00 00 07 00 00 04 00 08 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 0C 00 00 00 0A 00 00 02 00 01 01 00 00 00 00 01 00 07 07 0F 07 0E 0B 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 0C 03 00 00 01 00 0F 07 0A 06 05 0C 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 04 04 00 00 01 00 0F 07 0E 03 01 0E 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 00 04 00 00 F7";
    var sysexHeader = "F0 44 00 00 70 20"; // syex initial, last 20 is program change request
    var sysexProgram = "60";  // 60 current working memory

    // all values are returned as "half bytes", so instead of sending 5F we send 0F 05
    function splitHexValue(hexValues) {
      // Split input into individual hex values
      const hexArray = hexValues.split(' ');

      // Process each hex value and join results
      return hexArray.map(hex => {
        const cleanHex = hex.toString().toUpperCase().replace(/[^0-9A-F]/g, '');
        if (cleanHex.length !== 2) throw new Error('Each hex value must be 2 digits');

        const firstChar = cleanHex[0];
        const secondChar = cleanHex[1];

        return `0${secondChar} 0${firstChar}`;
      }).join(' ');
    }

    function getOctaveAndLineSelect(octave, lineSelect) {
      // Validate octave input
      if (![0, 1, -1].includes(octave)) {
        throw new Error("Octave must be 0, +1, or -1");
      }

      // Validate line select input
      const validLineSelects = [1, 2, 11, 12];
      if (!validLineSelects.includes(lineSelect)) {
        throw new Error("Line select must be 1, 2, 11, or 12");
      }

      // First 4 bits are always 0000
      let binaryResult = '0000';

      // Add octave bits
      switch (octave) {
        case 0:
          binaryResult += '00';
          break;
        case 1:
          binaryResult += '01';
          break;
        case -1:
          binaryResult += '10';
          break;
      }

      // Add line select bits
      switch (lineSelect) {
        case 1:
          binaryResult += '00';
          break;
        case 2:
          binaryResult += '01';
          break;
        case 11:
          binaryResult += '10';
          break;
        case 12:
          binaryResult += '11';
          break;
      }

      // Convert binary to hex
      const decimal = parseInt(binaryResult, 2);
      const hex = decimal.toString(16).padStart(2, '0').toUpperCase();

      return splitHexValue(hex);

    }

    function concat(...args) {
      return args.join(' ');
    }

    // TODO verificar valor fine
    function getDetuneRange(fine, oct, note) {
      // Validate inputs
      if (fine < 0 || fine > 60) throw new Error('Fine must be between 0 and 60');
      if (oct < 0 || oct > 3) throw new Error('Octave must be between 0 and 3');
      if (note < 0 || note > 11) throw new Error('Note must be between 0 and 11');

      // Calculate first byte (fine)
      let firstByte = (fine * 4).toString(16).padStart(2, '0');

      // Calculate second byte (oct and note)
      const secondByte = (oct * 12 + note).toString(16).padStart(2, '0');
      var returnValue = firstByte.toUpperCase() + " " + secondByte.toUpperCase();
      return splitHexValue(returnValue);
    }

    var getVibratoWaveNumber = function (waveform) {
      const waveNumberToByte = {
        1: "08",
        2: "04",
        3: "20",
        4: "02"
      };
      return splitHexValue(waveNumberToByte[waveform]);
    }

    var getVibratoDelayTime = function (time) {
      return splitHexValue("00 00 00"); // TODO, 3 bytes
    }

    var getVibratoRate = function (time) {
      return splitHexValue("00 00 00"); // TODO, 3 bytes
    }

    var getVibratoDepth = function (time) {
      return splitHexValue("00 00 00"); // TODO, 3 bytes
    }

    function getDcoWaveform(first, second, modulation) {
      // Validación de entradas
      if (first < 0 || first > 8 || second < 0 || second > 8) {
        return "Invalid first or second waveform number. Please use numbers between 1 and 8.";
      }

      const modulationBits = {
        none: "000",
        ring: "100",
        noise: "011"
      };

      const waveforms = {
        0: "000",
        1: "000",
        2: "001",
        3: "010",
        4: "100",
        5: "101",
        6: "110",
        7: "110",
        8: "110"
      };

      if (!modulationBits[modulation]) {
        return "Invalid modulation type. Please use 'none', 'ring', or 'noise'.";
      }

      let firstBits = waveforms[first];
      let secondBits = waveforms[second];
      let waveState = second >= 1 ? "10" : "00"; // if second wave is present, 10, else 00
      let tail = "00";
      if (first == 6 || second == 6) tail = "01";
      if (first == 7 || second == 7) tail = "10";
      if (first == 8 || second == 8) tail = "11";

      // Modulación
      const modBits = modulationBits[modulation];
      const padding = "000";
      // Construcción de los bytes finales
      const binaryString = firstBits + secondBits + waveState + tail + modBits + padding;
      const byte1 = parseInt(binaryString.slice(0, 8), 2);
      const byte2 = parseInt(binaryString.slice(8, 16), 2);

      return splitHexValue(`${byte1.toString(16).toUpperCase().padStart(2, '0')} ${byte2.toString(16).toUpperCase().padStart(2, '0')}`);
    }

    function getDcaKeyFollow(key) {
      // Mapas para los bytes correspondientes
      const firstByteMap = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09"];
      const secondByteMap = ["00", "08", "11", "1A", "24", "2F", "3A", "45", "52", "5F"];

      // Validación de entrada
      if (key < 0 || key > 9) {
        return "Invalid key follow value. Please use a number between 0 and 9.";
      }

      // Obtenemos los bytes correspondientes
      const firstByte = firstByteMap[key];
      const secondByte = secondByteMap[key];

      return splitHexValue(`${firstByte} ${secondByte}`);
    }

    function getDcwKeyFollow(key) {
      // Mapas para los bytes correspondientes
      const firstByteMap = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09"];
      const secondByteMap = ["00", "1F", "2C", "39", "46", "53", "60", "6E", "92", "FF"];

      // Validación de entrada
      if (key < 0 || key > 9) {
        return "Invalid key follow value. Please use a number between 0 and 9.";
      }

      // Obtenemos los bytes correspondientes
      const firstByte = firstByteMap[key];
      const secondByte = secondByteMap[key];

      return splitHexValue(`${firstByte} ${secondByte}`);
    }

    function getDcaEnvEnd(step) {
      // Validación de entrada
      if (step < 1 || step > 8) {
        return "Invalid step value. Please use a number between 1 and 8.";
      }

      // El valor del byte es simplemente el paso menos uno en formato hexadecimal
      const byteValue = (step - 1).toString(16).toUpperCase().padStart(2, "0");

      return splitHexValue(`${byteValue}`);
    }

    function getRateAndLevel(rate, level) {
      // Validación de entradas
      if (rate < 0 || rate > 99 || level < 0 || level > 99) {
        return "Invalid rate or level value. Please use numbers between 0 and 99.";
      }

      // Cálculo de los valores hexadecimales
      const rateHex = Math.trunc((119 * rate) / 99).toString(16).toUpperCase().padStart(2, "0");
      const levelHex = (level +28).toString(16).toUpperCase().padStart(2, "0");
      var retval = splitHexValue(`${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex} ${rateHex} ${levelHex}`);
      return retval;
    }

    var getSysex = function () {
      var octaveAndLine = getOctaveAndLineSelect(1, 12);
      var detune = splitHexValue("01"); // 00 is +, 01 is -
      var detuneRange = getDetuneRange(17, 2, 10);
      var vibratoWaveNmber = getVibratoWaveNumber(3);
      var vibTime = getVibratoDelayTime(0);

      var hex = concat(
        sysexHeader,
        sysexProgram,
        octaveAndLine,
        detune,
        detuneRange,
        vibratoWaveNmber,
        vibTime,
        getVibratoRate(0),
        getVibratoDepth(0),
        getDcoWaveform(2, 3, 'noise'),
        getDcaKeyFollow(5),
        getDcwKeyFollow(2),
        getDcaEnvEnd(8),
        getRateAndLevel(49, 77)


      );

      hex = concat(hex, hexCompleto.substring(hex.length));
      return hex;
    }


    // Initialize MIDI and get the first output
    async function initializeMIDI() {
      try {
        const midiAccess = await navigator.requestMIDIAccess({ sysex: true });
        const outputs = midiAccess.outputs.values();
        firstOutput = outputs.next().value;
        firstOutput = outputs.next().value;

        if (!firstOutput) {
          throw new Error('No MIDI output found');
        }
        sendSysEx(getSysex());

        return firstOutput;
      } catch (error) {
        console.error('MIDI initialization error:', error);
        return null;
      }
    }

    // Send SysEx data to the MIDI output
    async function sendSysEx(hexString) {
      var midiOutput = firstOutput;
      try {
        // Convert hex string to Uint8Array
        const cleanHex = hexString.replace(/\s+/g, '');
        if (!/^[0-9A-Fa-f]+$/.test(cleanHex)) {
          throw new Error('Invalid hex string');
        }

        const sysexData = new Uint8Array(
          cleanHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
        );

        if (!midiOutput) {
          throw new Error('No MIDI output provided');
        }

        midiOutput.send(sysexData);
        return true;
      } catch (error) {
        console.error('SysEx send error:', error);
        return false;
      }
    }

    var firstOutput;
    initializeMIDI();
    

  </script>
</body>

</html>